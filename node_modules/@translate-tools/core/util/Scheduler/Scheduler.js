"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;
var _QueueSemafor = require("../../lib/QueueSemafor");
var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Module for scheduling and optimization of translate a text streams
 *
 * - It can union many translate requests to one
 * - You can group any requests by context
 * - It's configurable. You can set retry limit and edge for direct translate
 */
var Scheduler = /** @class */function () {
  function Scheduler(translator, config) {
    var _this = this;
    this.config = {
      translateRetryAttemptLimit: 2,
      isAllowDirectTranslateBadChunks: true,
      directTranslateLength: null,
      translatePoolDelay: 300,
      chunkSizeForInstantTranslate: null,
      taskBatchHandleDelay: null
    };
    this.contextCounter = 0;
    this.taskContainersStorage = new Set();
    this.timersMap = new Map();
    /**
     * Tasks queue with items sorted by priority
     * It must be handled from end to start
     */
    this.translateQueue = [];
    /**
     * Return first item from queue and delete it from queue
     * Items is sorted by priority
     */
    this.getItemFromTranslateQueue = function () {
      var _a;
      return {
        done: _this.translateQueue.length === 0,
        value: (_a = _this.translateQueue.pop()) !== null && _a !== void 0 ? _a : null
      };
    };
    this.workerState = false;
    this.translator = translator;
    if (config !== undefined) {
      for (var key in config) {
        this.config[key] = config[key];
      }
    }
    this.semafor = new _QueueSemafor.QueueSemafor({
      timeout: translator.getRequestsTimeout()
    });
  }
  Scheduler.prototype.translate = function (text, from, to, options) {
    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, context, _c, priority, _d, directTranslateForThisRequest;
      return __generator(this, function (_e) {
        _a = options !== undefined ? options : {}, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.priority, priority = _c === void 0 ? 0 : _c, _d = _a.directTranslate, directTranslateForThisRequest = _d === void 0 ? false : _d;
        if (this.translator.checkLimitExceeding(text) <= 0) {
          // Direct translate
          if (directTranslateForThisRequest || this.config.directTranslateLength !== null && text.length >= this.config.directTranslateLength) {
            return [2 /*return*/, this.directTranslate(text, from, to)];
          } else {
            return [2 /*return*/, this.makeTask({
              text: text,
              from: from,
              to: to,
              context: context,
              priority: priority
            })];
          }
        } else {
          // Split text by words and translate
          return [2 /*return*/, this.splitAndTranslate(text, from, to, context, priority)];
        }
        return [2 /*return*/];
      });
    });
  };

  Scheduler.prototype.directTranslate = function (text, from, to) {
    return __awaiter(this, void 0, void 0, function () {
      var free;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, this.semafor.take()];
          case 1:
            free = _a.sent();
            return [2 /*return*/, this.translator.translate(text, from, to).finally(free)];
        }
      });
    });
  };
  Scheduler.prototype.splitAndTranslate = function (text, from, to, context, priority) {
    var e_1, _a;
    var _this = this;
    var splittedText = [];
    var charsetIndexes = [];
    var wordsBuffer = '';
    try {
      for (var _b = __values(text.matchAll(/([^\s]+)(\s*)/g)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var textMatch = _c.value;
        var newPart = textMatch[0];
        var newBuffer = wordsBuffer + newPart;
        // Add word to buffer if can
        if (this.translator.checkLimitExceeding(newBuffer) <= 0) {
          wordsBuffer = newBuffer;
          continue;
        }
        // Write and clear buffer if not empthy
        if (wordsBuffer.length > 0) {
          splittedText.push(wordsBuffer);
          wordsBuffer = '';
        }
        // Handle new part
        if (this.translator.checkLimitExceeding(newPart) <= 0) {
          // Add to buffer
          wordsBuffer += newPart;
          continue;
        } else {
          // Slice by chars
          var charsBuffer = newPart;
          while (charsBuffer.length > 0) {
            var extraChars = this.translator.checkLimitExceeding(charsBuffer);
            if (extraChars > 0) {
              var offset = charsBuffer.length - extraChars;
              // Write slice and remainder
              splittedText.push(charsBuffer.slice(0, offset));
              charsBuffer = charsBuffer.slice(offset);
              charsetIndexes.push(splittedText.length - 1);
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    var ctxPrefix = context.length > 0 ? context + ';' : '';
    return Promise.all(splittedText.map(function (text, index) {
      return charsetIndexes.indexOf(index) !== -1 ? text : _this.makeTask({
        text: text,
        from: from,
        to: to,
        context: ctxPrefix + "text#".concat(_this.contextCounter++),
        priority: priority
      });
    })).then(function (translatedParts) {
      return translatedParts.join('');
    });
  };
  Scheduler.prototype.makeTask = function (_a) {
    var _this = this;
    var text = _a.text,
      from = _a.from,
      to = _a.to,
      priority = _a.priority,
      _b = _a.context,
      context = _b === void 0 ? '' : _b;
    return new Promise(function (resolve, reject) {
      _this.addToTaskContainer({
        text: text,
        from: from,
        to: to,
        context: context,
        priority: priority,
        resolve: resolve,
        reject: reject
      });
    });
  };
  Scheduler.prototype.addToTaskContainer = function (params) {
    var e_2, _a;
    var text = params.text,
      from = params.from,
      to = params.to,
      _b = params.attempt,
      attempt = _b === void 0 ? 0 : _b,
      _c = params.context,
      context = _c === void 0 ? '' : _c,
      priority = params.priority,
      resolve = params.resolve,
      reject = params.reject;
    // create task
    var task = {
      text: text,
      from: from,
      to: to,
      attempt: attempt,
      resolve: resolve,
      reject: reject
    };
    var container = null;
    var _loop_1 = function (taskContainer) {
      // Skip containers with not equal parameters
      if (['from', 'to', 'context', 'priority'].some(function (key) {
        return params[key] !== taskContainer[key];
      })) return "continue";
      // Lightweight check to overflow
      // NOTE: Do strict check here if you need comply a limit contract
      if (this_1.translator.getLengthLimit() >= taskContainer.length + task.text.length) {
        taskContainer.tasks.push(task);
        taskContainer.length += task.text.length;
        container = taskContainer;
      }
    };
    var this_1 = this;
    try {
      // try add to exists container
      for (var _d = __values(this.taskContainersStorage), _e = _d.next(); !_e.done; _e = _d.next()) {
        var taskContainer = _e.value;
        _loop_1(taskContainer);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
    // make container
    if (container === null) {
      var newTaskContainer = {
        context: context,
        priority: priority,
        from: from,
        to: to,
        tasks: [task],
        length: task.text.length
      };
      this.taskContainersStorage.add(newTaskContainer);
      container = newTaskContainer;
    }
    if (this.config.chunkSizeForInstantTranslate !== null && container.length >= this.config.chunkSizeForInstantTranslate) {
      this.addToTranslateQueue(container);
    } else {
      this.updateDelayForAddToTranslateQueue(container);
    }
  };
  Scheduler.prototype.updateDelayForAddToTranslateQueue = function (taskContainer) {
    var _this = this;
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
    }
    this.timersMap.set(taskContainer, globalThis.setTimeout(function () {
      _this.addToTranslateQueue(taskContainer);
    }, this.config.translatePoolDelay));
  };
  Scheduler.prototype.addToTranslateQueue = function (taskContainer) {
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
      this.timersMap.delete(taskContainer);
    }
    this.taskContainersStorage.delete(taskContainer);
    // Resort queue by priority each time to keep consistency
    this.translateQueue = this.translateQueue.concat(taskContainer).sort(function (a, b) {
      return a.priority - b.priority;
    });
    if (!this.workerState) {
      this.runWorker();
    }
  };
  Scheduler.prototype.runWorker = function () {
    return __awaiter(this, void 0, void 0, function () {
      var firstIteration, _loop_2, this_2, state_1;
      var _this = this;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.workerState = true;
            firstIteration = true;
            _loop_2 = function () {
              var workerHandleDelay, iterate, taskContainer, free, textArray;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    workerHandleDelay = this_2.config.taskBatchHandleDelay;
                    if (!(workerHandleDelay && firstIteration)) return [3 /*break*/, 2];
                    return [4 /*yield*/, new Promise(function (res) {
                      return setTimeout(res, workerHandleDelay);
                    })];
                  case 1:
                    _b.sent();
                    _b.label = 2;
                  case 2:
                    firstIteration = false;
                    iterate = this_2.getItemFromTranslateQueue();
                    // Skip when queue empty
                    if (iterate.done || iterate.value === null) return [2 /*return*/, "break"];
                    taskContainer = iterate.value;
                    return [4 /*yield*/, this_2.semafor.take()];
                  case 3:
                    free = _b.sent();
                    textArray = taskContainer.tasks.map(function (i) {
                      return i.text;
                    });
                    return [4 /*yield*/, this_2.translator.translateBatch(textArray, taskContainer.from, taskContainer.to).then(function (result) {
                      for (var index in taskContainer.tasks) {
                        var task = taskContainer.tasks[index];
                        var translatedText = result[index];
                        if (translatedText !== null) {
                          task.resolve(translatedText);
                        } else {
                          _this.taskErrorHandler(task, new Error("Translator module can't translate this"), taskContainer.context, taskContainer.priority);
                        }
                      }
                    }).catch(function (reason) {
                      var e_3, _a;
                      console.error(reason);
                      try {
                        for (var _b = (e_3 = void 0, __values(taskContainer.tasks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var task = _c.value;
                          _this.taskErrorHandler(task, reason, taskContainer.context, taskContainer.priority);
                        }
                      } catch (e_3_1) {
                        e_3 = {
                          error: e_3_1
                        };
                      } finally {
                        try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                          if (e_3) throw e_3.error;
                        }
                      }
                    }).finally(free)];
                  case 4:
                    _b.sent();
                    return [2 /*return*/];
                }
              });
            };

            this_2 = this;
            _a.label = 1;
          case 1:
            if (!true) return [3 /*break*/, 3];
            return [5 /*yield**/, _loop_2()];
          case 2:
            state_1 = _a.sent();
            if (state_1 === "break") return [3 /*break*/, 3];
            return [3 /*break*/, 1];
          case 3:
            this.workerState = false;
            return [2 /*return*/];
        }
      });
    });
  };

  Scheduler.prototype.taskErrorHandler = function (task, error, context, priority) {
    if (task.attempt >= this.config.translateRetryAttemptLimit) {
      if (this.config.isAllowDirectTranslateBadChunks) {
        var text = task.text,
          from = task.from,
          to = task.to,
          resolve = task.resolve,
          reject = task.reject;
        this.directTranslate(text, from, to).then(resolve, reject);
      } else {
        task.reject(error);
      }
    } else {
      this.addToTaskContainer(__assign(__assign({}, task), {
        attempt: task.attempt + 1,
        context: context,
        priority: priority
      }));
    }
  };
  return Scheduler;
}();
exports.Scheduler = Scheduler;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC9TY2hlZHVsZXIvU2NoZWR1bGVyLmpzIiwibmFtZXMiOlsiX1F1ZXVlU2VtYWZvciIsInJlcXVpcmUiLCJTY2hlZHVsZXIiLCJ0cmFuc2xhdG9yIiwiY29uZmlnIiwiX3RoaXMiLCJ0cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdCIsImlzQWxsb3dEaXJlY3RUcmFuc2xhdGVCYWRDaHVua3MiLCJkaXJlY3RUcmFuc2xhdGVMZW5ndGgiLCJ0cmFuc2xhdGVQb29sRGVsYXkiLCJjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlIiwidGFza0JhdGNoSGFuZGxlRGVsYXkiLCJjb250ZXh0Q291bnRlciIsInRhc2tDb250YWluZXJzU3RvcmFnZSIsIlNldCIsInRpbWVyc01hcCIsIk1hcCIsInRyYW5zbGF0ZVF1ZXVlIiwiZ2V0SXRlbUZyb21UcmFuc2xhdGVRdWV1ZSIsImRvbmUiLCJsZW5ndGgiLCJ2YWx1ZSIsIl9hIiwicG9wIiwid29ya2VyU3RhdGUiLCJ1bmRlZmluZWQiLCJrZXkiLCJzZW1hZm9yIiwiUXVldWVTZW1hZm9yIiwidGltZW91dCIsImdldFJlcXVlc3RzVGltZW91dCIsInByb3RvdHlwZSIsInRyYW5zbGF0ZSIsInRleHQiLCJmcm9tIiwidG8iLCJvcHRpb25zIiwiX2IiLCJjb250ZXh0IiwiX2MiLCJwcmlvcml0eSIsIl9kIiwiZGlyZWN0VHJhbnNsYXRlIiwiZGlyZWN0VHJhbnNsYXRlRm9yVGhpc1JlcXVlc3QiLCJjaGVja0xpbWl0RXhjZWVkaW5nIiwibWFrZVRhc2siLCJzcGxpdEFuZFRyYW5zbGF0ZSIsInRha2UiLCJmcmVlIiwic2VudCIsImZpbmFsbHkiLCJzcGxpdHRlZFRleHQiLCJjaGFyc2V0SW5kZXhlcyIsIndvcmRzQnVmZmVyIiwiX192YWx1ZXMiLCJtYXRjaEFsbCIsIm5leHQiLCJ0ZXh0TWF0Y2giLCJuZXdQYXJ0IiwibmV3QnVmZmVyIiwicHVzaCIsImNoYXJzQnVmZmVyIiwiZXh0cmFDaGFycyIsIm9mZnNldCIsInNsaWNlIiwiY3R4UHJlZml4IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImluZGV4IiwiaW5kZXhPZiIsImNvbmNhdCIsInRoZW4iLCJ0cmFuc2xhdGVkUGFydHMiLCJqb2luIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZFRvVGFza0NvbnRhaW5lciIsInBhcmFtcyIsImF0dGVtcHQiLCJ0YXNrIiwiY29udGFpbmVyIiwidGFza0NvbnRhaW5lciIsInNvbWUiLCJ0aGlzXzEiLCJnZXRMZW5ndGhMaW1pdCIsInRhc2tzIiwiX2UiLCJuZXdUYXNrQ29udGFpbmVyIiwiYWRkIiwiYWRkVG9UcmFuc2xhdGVRdWV1ZSIsInVwZGF0ZURlbGF5Rm9yQWRkVG9UcmFuc2xhdGVRdWV1ZSIsImhhcyIsImdsb2JhbFRoaXMiLCJjbGVhclRpbWVvdXQiLCJnZXQiLCJzZXQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwic29ydCIsImEiLCJiIiwicnVuV29ya2VyIiwiZmlyc3RJdGVyYXRpb24iLCJ3b3JrZXJIYW5kbGVEZWxheSIsInRoaXNfMiIsInJlcyIsIml0ZXJhdGUiLCJ0ZXh0QXJyYXkiLCJpIiwidHJhbnNsYXRlQmF0Y2giLCJyZXN1bHQiLCJ0cmFuc2xhdGVkVGV4dCIsInRhc2tFcnJvckhhbmRsZXIiLCJFcnJvciIsImNhdGNoIiwicmVhc29uIiwiY29uc29sZSIsImVycm9yIiwiZV8zIiwiX19hc3NpZ24iLCJleHBvcnRzIl0sInNvdXJjZXMiOlsidXRpbC9TY2hlZHVsZXIvU2NoZWR1bGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElUcmFuc2xhdGVPcHRpb25zLCBJU2NoZWR1bGVyIH0gZnJvbSAnLi9JU2NoZWR1bGVyJztcbmltcG9ydCB7XG5cdGxhbmdDb2RlLFxuXHRsYW5nQ29kZVdpdGhBdXRvLFxuXHRUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLFxufSBmcm9tICcuLi8uLi90eXBlcy9UcmFuc2xhdG9yJztcbmltcG9ydCB7IFF1ZXVlU2VtYWZvciB9IGZyb20gJy4uLy4uL2xpYi9RdWV1ZVNlbWFmb3InO1xuXG5pbnRlcmZhY2UgQ29uZmlnIHtcblx0LyoqXG5cdCAqIE51bWJlciBvZiBhdHRlbXB0cyBmb3IgcmV0cnkgcmVxdWVzdFxuXHQgKi9cblx0dHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQ/OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIElmIHRydWUgLSByZWplY3RlZCByZXF1ZXN0cyB3aWxsIHVzZSBkaXJlY3QgdHJhbnNsYXRlXG5cdCAqL1xuXHRpc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzPzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogTGVuZ3RoIG9mIHN0cmluZyBmb3IgZGlyZWN0IHRyYW5zbGF0ZS5cblx0ICpcblx0ICogbnVsbCBmb3IgZGlzYWJsZSB0aGUgY29uZGl0aW9uXG5cdCAqL1xuXHRkaXJlY3RUcmFuc2xhdGVMZW5ndGg/OiBudW1iZXIgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBEZWxheSBmb3IgdHJhbnNsYXRlIGEgY2h1bmsuIFRoZSBiaWdnZXIgdGhlIG1vcmUgcmVxdWVzdHMgd2lsbCBjb2xsZWN0XG5cdCAqL1xuXHR0cmFuc2xhdGVQb29sRGVsYXk/OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFdoZW4gY2h1bmsgY29sbGVjdCB0aGlzIHNpemUsIGl0J3Mgd2lsbCBiZSBpbnN0YW50IGFkZCB0byBhIHRyYW5zbGF0ZSBxdWV1ZVxuXHQgKlxuXHQgKiBudWxsIGZvciBkaXNhYmxlIHRoZSBjb25kaXRpb25cblx0ICovXG5cdGNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGU/OiBudW1iZXIgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBQYXVzZSBiZXR3ZWVuIGhhbmRsZSB0YXNrIGJhdGNoZXNcblx0ICpcblx0ICogSXQgbWF5IGJlIHVzZWZ1bCB0byBhd2FpdCBhY2N1bXVsYXRpbmcgYSB0YXNrIGJhdGNoZXMgaW4gcXVldWUgdG8gY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyIGFuZCBkb24ndCB0cmFuc2xhdGUgZmlyc3QgdGFzayBiYXRjaCBpbW1lZGlhdGVseVxuXHQgKlxuXHQgKiBXQVJOSU5HOiB0aGlzIG9wdGlvbiBtdXN0IGJlIHVzZWQgb25seSBmb3IgY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyISBTZXQgc21hbGwgdmFsdWUgYWx3YXlzICgxMC01MG1zKVxuXHQgKlxuXHQgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIGRpc2FibGVkIChieSBkZWZhdWx0KSBhbmQgeW91IGNhbGwgdHJhbnNsYXRlIG1ldGhvZCBmb3IgdGV4dHMgd2l0aCBwcmlvcml0eSAxIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGZvciB0ZXh0IHdpdGggcHJpb3JpdHkgMiwgZmlyc3QgcmVxdWVzdCB3aWxsIGhhdmUgbGVzcyBkZWxheSBmb3IgdHJhbnNsYXRlIGFuZCB3aWxsIHRyYW5zbGF0ZSBmaXJzdCwgZXZlbiB3aXRoIGxvd2VyIHByaW9yaXR5LCBiZWNhdXNlIHdvcmtlciB3aWxsIHRyYW5zbGF0ZSBmaXJzdCB0YXNrIGltbWVkaWF0ZWx5IGFmdGVyIGRlbGF5IGRlZmluZWQgYnkgb3B0aW9uIGB0cmFuc2xhdGVQb29sRGVsYXlgXG5cdCAqL1xuXHR0YXNrQmF0Y2hIYW5kbGVEZWxheT86IG51bGwgfCBudW1iZXI7XG59XG5cbmludGVyZmFjZSBUYXNrQ29uc3RydWN0b3Ige1xuXHR0ZXh0OiBzdHJpbmc7XG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblxuXHQvKipcblx0ICogVG8gY29tYmluZSB0YXNrcyBieSB1bmlxdWUga2V5XG5cdCAqL1xuXHRjb250ZXh0Pzogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUbyBjb21iaW5lIGFuZCBzb3J0IHRhc2tzIGJ5IHByaW9yaXR5XG5cdCAqL1xuXHRwcmlvcml0eTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVGFza0NvbnN0cnVjdG9ySW50ZXJuYWwgZXh0ZW5kcyBUYXNrQ29uc3RydWN0b3Ige1xuXHQvKipcblx0ICogQ3VycmVudCByZXRyeSBhdHRlbXB0XG5cdCAqL1xuXHRhdHRlbXB0PzogbnVtYmVyO1xuXG5cdHJlc29sdmU6ICh2YWx1ZTogc3RyaW5nIHwgUHJvbWlzZUxpa2U8c3RyaW5nPikgPT4gdm9pZDtcblx0cmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVGFzayB7XG5cdHRleHQ6IHN0cmluZztcblx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0bztcblx0dG86IGxhbmdDb2RlO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IHJldHJ5IGF0dGVtcHRcblx0ICovXG5cdGF0dGVtcHQ6IG51bWJlcjtcblxuXHRyZXNvbHZlOiAodmFsdWU6IHN0cmluZyB8IFByb21pc2VMaWtlPHN0cmluZz4pID0+IHZvaWQ7XG5cdHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFRhc2tDb250YWluZXIge1xuXHQvKipcblx0ICogRm9yIGNvbWJpbmUgdGFza3MgYnkgdW5pcXVlIGtleVxuXHQgKi9cblx0Y29udGV4dDogc3RyaW5nO1xuXG5cdHByaW9yaXR5OiBudW1iZXI7XG5cblx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0bztcblx0dG86IGxhbmdDb2RlO1xuXHR0YXNrczogVGFza1tdO1xuXG5cdC8qKlxuXHQgKiBUb3RhbCBsZW5ndGggb2YgdGV4dCBmcm9tIGFsbCB0YXNrc1xuXHQgKi9cblx0bGVuZ3RoOiBudW1iZXI7XG59XG5cbnR5cGUgSXRlcmF0b3JTdGVwPFQ+ID0ge1xuXHRkb25lOiBib29sZWFuO1xuXHR2YWx1ZTogVCB8IG51bGw7XG59O1xuXG4vKipcbiAqIE1vZHVsZSBmb3Igc2NoZWR1bGluZyBhbmQgb3B0aW1pemF0aW9uIG9mIHRyYW5zbGF0ZSBhIHRleHQgc3RyZWFtc1xuICpcbiAqIC0gSXQgY2FuIHVuaW9uIG1hbnkgdHJhbnNsYXRlIHJlcXVlc3RzIHRvIG9uZVxuICogLSBZb3UgY2FuIGdyb3VwIGFueSByZXF1ZXN0cyBieSBjb250ZXh0XG4gKiAtIEl0J3MgY29uZmlndXJhYmxlLiBZb3UgY2FuIHNldCByZXRyeSBsaW1pdCBhbmQgZWRnZSBmb3IgZGlyZWN0IHRyYW5zbGF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2NoZWR1bGVyIGltcGxlbWVudHMgSVNjaGVkdWxlciB7XG5cdHByaXZhdGUgcmVhZG9ubHkgc2VtYWZvcjtcblx0cHJpdmF0ZSByZWFkb25seSB0cmFuc2xhdG9yO1xuXHRwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogUmVxdWlyZWQ8Q29uZmlnPiA9IHtcblx0XHR0cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdDogMixcblx0XHRpc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzOiB0cnVlLFxuXHRcdGRpcmVjdFRyYW5zbGF0ZUxlbmd0aDogbnVsbCxcblx0XHR0cmFuc2xhdGVQb29sRGVsYXk6IDMwMCxcblx0XHRjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlOiBudWxsLFxuXHRcdHRhc2tCYXRjaEhhbmRsZURlbGF5OiBudWxsLFxuXHR9O1xuXG5cdGNvbnN0cnVjdG9yKHRyYW5zbGF0b3I6IFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnMsIGNvbmZpZz86IENvbmZpZykge1xuXHRcdHRoaXMudHJhbnNsYXRvciA9IHRyYW5zbGF0b3I7XG5cblx0XHRpZiAoY29uZmlnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuXHRcdFx0XHQodGhpcy5jb25maWcgYXMgYW55KVtrZXldID0gKGNvbmZpZyBhcyBhbnkpW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZW1hZm9yID0gbmV3IFF1ZXVlU2VtYWZvcih7IHRpbWVvdXQ6IHRyYW5zbGF0b3IuZ2V0UmVxdWVzdHNUaW1lb3V0KCkgfSk7XG5cdH1cblxuXHRwcml2YXRlIGNvbnRleHRDb3VudGVyID0gMDtcblx0cHVibGljIGFzeW5jIHRyYW5zbGF0ZShcblx0XHR0ZXh0OiBzdHJpbmcsXG5cdFx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0byxcblx0XHR0bzogbGFuZ0NvZGUsXG5cdFx0b3B0aW9ucz86IElUcmFuc2xhdGVPcHRpb25zLFxuXHQpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRjb250ZXh0ID0gJycsXG5cdFx0XHRwcmlvcml0eSA9IDAsXG5cdFx0XHRkaXJlY3RUcmFuc2xhdGU6IGRpcmVjdFRyYW5zbGF0ZUZvclRoaXNSZXF1ZXN0ID0gZmFsc2UsXG5cdFx0fSA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcblxuXHRcdGlmICh0aGlzLnRyYW5zbGF0b3IuY2hlY2tMaW1pdEV4Y2VlZGluZyh0ZXh0KSA8PSAwKSB7XG5cdFx0XHQvLyBEaXJlY3QgdHJhbnNsYXRlXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGRpcmVjdFRyYW5zbGF0ZUZvclRoaXNSZXF1ZXN0IHx8XG5cdFx0XHRcdCh0aGlzLmNvbmZpZy5kaXJlY3RUcmFuc2xhdGVMZW5ndGggIT09IG51bGwgJiZcblx0XHRcdFx0XHR0ZXh0Lmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5kaXJlY3RUcmFuc2xhdGVMZW5ndGgpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGlyZWN0VHJhbnNsYXRlKHRleHQsIGZyb20sIHRvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1ha2VUYXNrKHsgdGV4dDogdGV4dCwgZnJvbSwgdG8sIGNvbnRleHQsIHByaW9yaXR5IH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTcGxpdCB0ZXh0IGJ5IHdvcmRzIGFuZCB0cmFuc2xhdGVcblx0XHRcdHJldHVybiB0aGlzLnNwbGl0QW5kVHJhbnNsYXRlKHRleHQsIGZyb20sIHRvLCBjb250ZXh0LCBwcmlvcml0eSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBkaXJlY3RUcmFuc2xhdGUodGV4dDogc3RyaW5nLCBmcm9tOiBsYW5nQ29kZVdpdGhBdXRvLCB0bzogbGFuZ0NvZGUpIHtcblx0XHRjb25zdCBmcmVlID0gYXdhaXQgdGhpcy5zZW1hZm9yLnRha2UoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bykuZmluYWxseShmcmVlKTtcblx0fVxuXG5cdHByaXZhdGUgc3BsaXRBbmRUcmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGZyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0dG86IGxhbmdDb2RlLFxuXHRcdGNvbnRleHQ6IHN0cmluZyxcblx0XHRwcmlvcml0eTogbnVtYmVyLFxuXHQpIHtcblx0XHRjb25zdCBzcGxpdHRlZFRleHQ6IHN0cmluZ1tdID0gW107XG5cdFx0Y29uc3QgY2hhcnNldEluZGV4ZXM6IG51bWJlcltdID0gW107XG5cblx0XHRsZXQgd29yZHNCdWZmZXIgPSAnJztcblx0XHRmb3IgKGNvbnN0IHRleHRNYXRjaCBvZiB0ZXh0Lm1hdGNoQWxsKC8oW15cXHNdKykoXFxzKikvZykpIHtcblx0XHRcdGNvbnN0IG5ld1BhcnQgPSB0ZXh0TWF0Y2hbMF07XG5cdFx0XHRjb25zdCBuZXdCdWZmZXIgPSB3b3Jkc0J1ZmZlciArIG5ld1BhcnQ7XG5cblx0XHRcdC8vIEFkZCB3b3JkIHRvIGJ1ZmZlciBpZiBjYW5cblx0XHRcdGlmICh0aGlzLnRyYW5zbGF0b3IuY2hlY2tMaW1pdEV4Y2VlZGluZyhuZXdCdWZmZXIpIDw9IDApIHtcblx0XHRcdFx0d29yZHNCdWZmZXIgPSBuZXdCdWZmZXI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcml0ZSBhbmQgY2xlYXIgYnVmZmVyIGlmIG5vdCBlbXB0aHlcblx0XHRcdGlmICh3b3Jkc0J1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNwbGl0dGVkVGV4dC5wdXNoKHdvcmRzQnVmZmVyKTtcblx0XHRcdFx0d29yZHNCdWZmZXIgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIG5ldyBwYXJ0XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcobmV3UGFydCkgPD0gMCkge1xuXHRcdFx0XHQvLyBBZGQgdG8gYnVmZmVyXG5cdFx0XHRcdHdvcmRzQnVmZmVyICs9IG5ld1BhcnQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU2xpY2UgYnkgY2hhcnNcblx0XHRcdFx0bGV0IGNoYXJzQnVmZmVyID0gbmV3UGFydDtcblx0XHRcdFx0d2hpbGUgKGNoYXJzQnVmZmVyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zdCBleHRyYUNoYXJzID0gdGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcoY2hhcnNCdWZmZXIpO1xuXHRcdFx0XHRcdGlmIChleHRyYUNoYXJzID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gY2hhcnNCdWZmZXIubGVuZ3RoIC0gZXh0cmFDaGFycztcblxuXHRcdFx0XHRcdFx0Ly8gV3JpdGUgc2xpY2UgYW5kIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0c3BsaXR0ZWRUZXh0LnB1c2goY2hhcnNCdWZmZXIuc2xpY2UoMCwgb2Zmc2V0KSk7XG5cdFx0XHRcdFx0XHRjaGFyc0J1ZmZlciA9IGNoYXJzQnVmZmVyLnNsaWNlKG9mZnNldCk7XG5cblx0XHRcdFx0XHRcdGNoYXJzZXRJbmRleGVzLnB1c2goc3BsaXR0ZWRUZXh0Lmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGN0eFByZWZpeCA9IGNvbnRleHQubGVuZ3RoID4gMCA/IGNvbnRleHQgKyAnOycgOiAnJztcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXG5cdFx0XHRzcGxpdHRlZFRleHQubWFwKCh0ZXh0LCBpbmRleCkgPT5cblx0XHRcdFx0Y2hhcnNldEluZGV4ZXMuaW5kZXhPZihpbmRleCkgIT09IC0xXG5cdFx0XHRcdFx0PyB0ZXh0XG5cdFx0XHRcdFx0OiB0aGlzLm1ha2VUYXNrKHtcblx0XHRcdFx0XHRcdHRleHQsXG5cdFx0XHRcdFx0XHRmcm9tLFxuXHRcdFx0XHRcdFx0dG8sXG5cdFx0XHRcdFx0XHRjb250ZXh0OiBjdHhQcmVmaXggKyBgdGV4dCMke3RoaXMuY29udGV4dENvdW50ZXIrK31gLFxuXHRcdFx0XHRcdFx0cHJpb3JpdHksXG5cdFx0XHRcdFx0ICB9KSxcblx0XHRcdCksXG5cdFx0KS50aGVuKCh0cmFuc2xhdGVkUGFydHMpID0+IHRyYW5zbGF0ZWRQYXJ0cy5qb2luKCcnKSk7XG5cdH1cblxuXHRwcml2YXRlIG1ha2VUYXNrKHsgdGV4dCwgZnJvbSwgdG8sIHByaW9yaXR5LCBjb250ZXh0ID0gJycgfTogVGFza0NvbnN0cnVjdG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0dGhpcy5hZGRUb1Rhc2tDb250YWluZXIoe1xuXHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRmcm9tLFxuXHRcdFx0XHR0byxcblx0XHRcdFx0Y29udGV4dCxcblx0XHRcdFx0cHJpb3JpdHksXG5cdFx0XHRcdHJlc29sdmUsXG5cdFx0XHRcdHJlamVjdCxcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSB0YXNrQ29udGFpbmVyc1N0b3JhZ2UgPSBuZXcgU2V0PFRhc2tDb250YWluZXI+KCk7XG5cdHByaXZhdGUgYWRkVG9UYXNrQ29udGFpbmVyKHBhcmFtczogVGFza0NvbnN0cnVjdG9ySW50ZXJuYWwpIHtcblx0XHRjb25zdCB7XG5cdFx0XHR0ZXh0LFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvLFxuXHRcdFx0YXR0ZW1wdCA9IDAsXG5cdFx0XHRjb250ZXh0ID0gJycsXG5cdFx0XHRwcmlvcml0eSxcblx0XHRcdHJlc29sdmUsXG5cdFx0XHRyZWplY3QsXG5cdFx0fSA9IHBhcmFtcztcblxuXHRcdC8vIGNyZWF0ZSB0YXNrXG5cdFx0Y29uc3QgdGFzazogVGFzayA9IHtcblx0XHRcdHRleHQsXG5cdFx0XHRmcm9tLFxuXHRcdFx0dG8sXG5cdFx0XHRhdHRlbXB0LFxuXHRcdFx0cmVzb2x2ZSxcblx0XHRcdHJlamVjdCxcblx0XHR9O1xuXG5cdFx0bGV0IGNvbnRhaW5lcjogVGFza0NvbnRhaW5lciB8IG51bGwgPSBudWxsO1xuXG5cdFx0Ly8gdHJ5IGFkZCB0byBleGlzdHMgY29udGFpbmVyXG5cdFx0Zm9yIChjb25zdCB0YXNrQ29udGFpbmVyIG9mIHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlKSB7XG5cdFx0XHQvLyBTa2lwIGNvbnRhaW5lcnMgd2l0aCBub3QgZXF1YWwgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRbJ2Zyb20nLCAndG8nLCAnY29udGV4dCcsICdwcmlvcml0eSddLnNvbWUoXG5cdFx0XHRcdFx0KGtleSkgPT4gKHBhcmFtcyBhcyBhbnkpW2tleV0gIT09ICh0YXNrQ29udGFpbmVyIGFzIGFueSlba2V5XSxcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly8gTGlnaHR3ZWlnaHQgY2hlY2sgdG8gb3ZlcmZsb3dcblx0XHRcdC8vIE5PVEU6IERvIHN0cmljdCBjaGVjayBoZXJlIGlmIHlvdSBuZWVkIGNvbXBseSBhIGxpbWl0IGNvbnRyYWN0XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMudHJhbnNsYXRvci5nZXRMZW5ndGhMaW1pdCgpID49XG5cdFx0XHRcdHRhc2tDb250YWluZXIubGVuZ3RoICsgdGFzay50ZXh0Lmxlbmd0aFxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhc2tDb250YWluZXIudGFza3MucHVzaCh0YXNrKTtcblx0XHRcdFx0dGFza0NvbnRhaW5lci5sZW5ndGggKz0gdGFzay50ZXh0Lmxlbmd0aDtcblx0XHRcdFx0Y29udGFpbmVyID0gdGFza0NvbnRhaW5lcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBtYWtlIGNvbnRhaW5lclxuXHRcdGlmIChjb250YWluZXIgPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IG5ld1Rhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIgPSB7XG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRmcm9tLFxuXHRcdFx0XHR0byxcblx0XHRcdFx0dGFza3M6IFt0YXNrXSxcblx0XHRcdFx0bGVuZ3RoOiB0YXNrLnRleHQubGVuZ3RoLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlLmFkZChuZXdUYXNrQ29udGFpbmVyKTtcblx0XHRcdGNvbnRhaW5lciA9IG5ld1Rhc2tDb250YWluZXI7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5jb25maWcuY2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZSAhPT0gbnVsbCAmJlxuXHRcdFx0Y29udGFpbmVyLmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5jaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLmFkZFRvVHJhbnNsYXRlUXVldWUoY29udGFpbmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGVEZWxheUZvckFkZFRvVHJhbnNsYXRlUXVldWUoY29udGFpbmVyKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlYWRvbmx5IHRpbWVyc01hcCA9IG5ldyBNYXA8VGFza0NvbnRhaW5lciwgbnVtYmVyIHwgTm9kZUpTLlRpbWVvdXQ+KCk7XG5cdHByaXZhdGUgdXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIpIHtcblx0XHQvLyBGbHVzaCB0aW1lclxuXHRcdGlmICh0aGlzLnRpbWVyc01hcC5oYXModGFza0NvbnRhaW5lcikpIHtcblx0XHRcdC8vIER1ZSB0byBleHBlY3RhdGlvbiBydW4gb24gb25lIHBsYXRmb3JtLCB0aW1lciBvYmplY3RzIHdpbGwgc2FtZSBhbHdheXNcblx0XHRcdGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzTWFwLmdldCh0YXNrQ29udGFpbmVyKSBhcyBhbnkpO1xuXHRcdH1cblxuXHRcdHRoaXMudGltZXJzTWFwLnNldChcblx0XHRcdHRhc2tDb250YWluZXIsXG5cdFx0XHRnbG9iYWxUaGlzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmFkZFRvVHJhbnNsYXRlUXVldWUodGFza0NvbnRhaW5lcik7XG5cdFx0XHR9LCB0aGlzLmNvbmZpZy50cmFuc2xhdGVQb29sRGVsYXkpLFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVGFza3MgcXVldWUgd2l0aCBpdGVtcyBzb3J0ZWQgYnkgcHJpb3JpdHlcblx0ICogSXQgbXVzdCBiZSBoYW5kbGVkIGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqL1xuXHRwcml2YXRlIHRyYW5zbGF0ZVF1ZXVlOiBUYXNrQ29udGFpbmVyW10gPSBbXTtcblx0cHJpdmF0ZSBhZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIpIHtcblx0XHQvLyBGbHVzaCB0aW1lclxuXHRcdGlmICh0aGlzLnRpbWVyc01hcC5oYXModGFza0NvbnRhaW5lcikpIHtcblx0XHRcdC8vIER1ZSB0byBleHBlY3RhdGlvbiBydW4gb24gb25lIHBsYXRmb3JtLCB0aW1lciBvYmplY3RzIHdpbGwgc2FtZSBhbHdheXNcblx0XHRcdGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzTWFwLmdldCh0YXNrQ29udGFpbmVyKSBhcyBhbnkpO1xuXHRcdFx0dGhpcy50aW1lcnNNYXAuZGVsZXRlKHRhc2tDb250YWluZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlLmRlbGV0ZSh0YXNrQ29udGFpbmVyKTtcblxuXHRcdC8vIFJlc29ydCBxdWV1ZSBieSBwcmlvcml0eSBlYWNoIHRpbWUgdG8ga2VlcCBjb25zaXN0ZW5jeVxuXHRcdHRoaXMudHJhbnNsYXRlUXVldWUgPSB0aGlzLnRyYW5zbGF0ZVF1ZXVlXG5cdFx0XHQuY29uY2F0KHRhc2tDb250YWluZXIpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG5cdFx0aWYgKCF0aGlzLndvcmtlclN0YXRlKSB7XG5cdFx0XHR0aGlzLnJ1bldvcmtlcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZmlyc3QgaXRlbSBmcm9tIHF1ZXVlIGFuZCBkZWxldGUgaXQgZnJvbSBxdWV1ZVxuXHQgKiBJdGVtcyBpcyBzb3J0ZWQgYnkgcHJpb3JpdHlcblx0ICovXG5cdHByaXZhdGUgZ2V0SXRlbUZyb21UcmFuc2xhdGVRdWV1ZSA9ICgpOiBJdGVyYXRvclN0ZXA8VGFza0NvbnRhaW5lcj4gPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkb25lOiB0aGlzLnRyYW5zbGF0ZVF1ZXVlLmxlbmd0aCA9PT0gMCxcblx0XHRcdHZhbHVlOiB0aGlzLnRyYW5zbGF0ZVF1ZXVlLnBvcCgpID8/IG51bGwsXG5cdFx0fTtcblx0fTtcblxuXHRwcml2YXRlIHdvcmtlclN0YXRlID0gZmFsc2U7XG5cdHByaXZhdGUgYXN5bmMgcnVuV29ya2VyKCkge1xuXHRcdHRoaXMud29ya2VyU3RhdGUgPSB0cnVlO1xuXG5cdFx0bGV0IGZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Ly8gRGVsYXkgZmlyc3QgaXRlcmF0aW9uIHRvIGF3YWl0IGZpbGwgdGhlIHF1ZXVlLCB0byBjb25zaWRlciBwcmlvcml0eSBiZXR0ZXJcblx0XHRcdGNvbnN0IHdvcmtlckhhbmRsZURlbGF5ID0gdGhpcy5jb25maWcudGFza0JhdGNoSGFuZGxlRGVsYXk7XG5cdFx0XHRpZiAod29ya2VySGFuZGxlRGVsYXkgJiYgZmlyc3RJdGVyYXRpb24pIHtcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIHdvcmtlckhhbmRsZURlbGF5KSk7XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0SXRlcmF0aW9uID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGl0ZXJhdGUgPSB0aGlzLmdldEl0ZW1Gcm9tVHJhbnNsYXRlUXVldWUoKTtcblxuXHRcdFx0Ly8gU2tpcCB3aGVuIHF1ZXVlIGVtcHR5XG5cdFx0XHRpZiAoaXRlcmF0ZS5kb25lIHx8IGl0ZXJhdGUudmFsdWUgPT09IG51bGwpIGJyZWFrO1xuXG5cdFx0XHRjb25zdCB0YXNrQ29udGFpbmVyID0gaXRlcmF0ZS52YWx1ZTtcblxuXHRcdFx0Y29uc3QgZnJlZSA9IGF3YWl0IHRoaXMuc2VtYWZvci50YWtlKCk7XG5cblx0XHRcdGNvbnN0IHRleHRBcnJheSA9IHRhc2tDb250YWluZXIudGFza3MubWFwKChpKSA9PiBpLnRleHQpO1xuXHRcdFx0YXdhaXQgdGhpcy50cmFuc2xhdG9yXG5cdFx0XHRcdC50cmFuc2xhdGVCYXRjaCh0ZXh0QXJyYXksIHRhc2tDb250YWluZXIuZnJvbSwgdGFza0NvbnRhaW5lci50bylcblx0XHRcdFx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgaW5kZXggaW4gdGFza0NvbnRhaW5lci50YXNrcykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGFzayA9IHRhc2tDb250YWluZXIudGFza3NbaW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmFuc2xhdGVkVGV4dCA9IHJlc3VsdFtpbmRleF07XG5cdFx0XHRcdFx0XHRpZiAodHJhbnNsYXRlZFRleHQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dGFzay5yZXNvbHZlKHRyYW5zbGF0ZWRUZXh0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudGFza0Vycm9ySGFuZGxlcihcblx0XHRcdFx0XHRcdFx0XHR0YXNrLFxuXHRcdFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIlRyYW5zbGF0b3IgbW9kdWxlIGNhbid0IHRyYW5zbGF0ZSB0aGlzXCIpLFxuXHRcdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIuY29udGV4dCxcblx0XHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLnByaW9yaXR5LFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKChyZWFzb24pID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKHJlYXNvbik7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHRhc2sgb2YgdGFza0NvbnRhaW5lci50YXNrcykge1xuXHRcdFx0XHRcdFx0dGhpcy50YXNrRXJyb3JIYW5kbGVyKFxuXHRcdFx0XHRcdFx0XHR0YXNrLFxuXHRcdFx0XHRcdFx0XHRyZWFzb24sXG5cdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIuY29udGV4dCxcblx0XHRcdFx0XHRcdFx0dGFza0NvbnRhaW5lci5wcmlvcml0eSxcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmluYWxseShmcmVlKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlclN0YXRlID0gZmFsc2U7XG5cdH1cblxuXHRwcml2YXRlIHRhc2tFcnJvckhhbmRsZXIodGFzazogVGFzaywgZXJyb3I6IGFueSwgY29udGV4dDogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyKSB7XG5cdFx0aWYgKHRhc2suYXR0ZW1wdCA+PSB0aGlzLmNvbmZpZy50cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdCkge1xuXHRcdFx0aWYgKHRoaXMuY29uZmlnLmlzQWxsb3dEaXJlY3RUcmFuc2xhdGVCYWRDaHVua3MpIHtcblx0XHRcdFx0Y29uc3QgeyB0ZXh0LCBmcm9tLCB0bywgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0YXNrO1xuXHRcdFx0XHR0aGlzLmRpcmVjdFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFzay5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFkZFRvVGFza0NvbnRhaW5lcih7XG5cdFx0XHRcdC4uLnRhc2ssXG5cdFx0XHRcdGF0dGVtcHQ6IHRhc2suYXR0ZW1wdCArIDEsXG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQU1BLElBQUFBLGFBQUEsR0FBQUMsT0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJHQTs7Ozs7OztBQU9BLElBQUFDLFNBQUE7RUFZQyxTQUFBQSxVQUFZQyxVQUFxQyxFQUFFQyxNQUFlO0lBQWxFLElBQUFDLEtBQUE7SUFUaUIsS0FBQUQsTUFBTSxHQUFxQjtNQUMzQ0UsMEJBQTBCLEVBQUUsQ0FBQztNQUM3QkMsK0JBQStCLEVBQUUsSUFBSTtNQUNyQ0MscUJBQXFCLEVBQUUsSUFBSTtNQUMzQkMsa0JBQWtCLEVBQUUsR0FBRztNQUN2QkMsNEJBQTRCLEVBQUUsSUFBSTtNQUNsQ0Msb0JBQW9CLEVBQUU7S0FDdEI7SUFjTyxLQUFBQyxjQUFjLEdBQUcsQ0FBQztJQW1IVCxLQUFBQyxxQkFBcUIsR0FBRyxJQUFJQyxHQUFHLEVBQWlCO0lBdUVoRCxLQUFBQyxTQUFTLEdBQUcsSUFBSUMsR0FBRyxFQUEwQztJQWdCOUU7Ozs7SUFJUSxLQUFBQyxjQUFjLEdBQW9CLEVBQUU7SUFxQjVDOzs7O0lBSVEsS0FBQUMseUJBQXlCLEdBQUc7O01BQ25DLE9BQU87UUFDTkMsSUFBSSxFQUFFZCxLQUFJLENBQUNZLGNBQWMsQ0FBQ0csTUFBTSxLQUFLLENBQUM7UUFDdENDLEtBQUssRUFBRSxDQUFBQyxFQUFBLEdBQUFqQixLQUFJLENBQUNZLGNBQWMsQ0FBQ00sR0FBRyxFQUFF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
