var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { QueueSemafor } from '../../lib/QueueSemafor';
/**
 * Module for scheduling and optimization of translate a text streams
 *
 * - It can union many translate requests to one
 * - You can group any requests by context
 * - It's configurable. You can set retry limit and edge for direct translate
 */
var Scheduler = /** @class */ (function () {
    function Scheduler(translator, config) {
        var _this = this;
        this.config = {
            translateRetryAttemptLimit: 2,
            isAllowDirectTranslateBadChunks: true,
            directTranslateLength: null,
            translatePoolDelay: 300,
            chunkSizeForInstantTranslate: null,
            taskBatchHandleDelay: null,
        };
        this.contextCounter = 0;
        this.taskContainersStorage = new Set();
        this.timersMap = new Map();
        /**
         * Tasks queue with items sorted by priority
         * It must be handled from end to start
         */
        this.translateQueue = [];
        /**
         * Return first item from queue and delete it from queue
         * Items is sorted by priority
         */
        this.getItemFromTranslateQueue = function () {
            var _a;
            return {
                done: _this.translateQueue.length === 0,
                value: (_a = _this.translateQueue.pop()) !== null && _a !== void 0 ? _a : null,
            };
        };
        this.workerState = false;
        this.translator = translator;
        if (config !== undefined) {
            for (var key in config) {
                this.config[key] = config[key];
            }
        }
        this.semafor = new QueueSemafor({ timeout: translator.getRequestsTimeout() });
    }
    Scheduler.prototype.translate = function (text, from, to, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, context, _c, priority, _d, directTranslateForThisRequest;
            return __generator(this, function (_e) {
                _a = options !== undefined ? options : {}, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.priority, priority = _c === void 0 ? 0 : _c, _d = _a.directTranslate, directTranslateForThisRequest = _d === void 0 ? false : _d;
                if (this.translator.checkLimitExceeding(text) <= 0) {
                    // Direct translate
                    if (directTranslateForThisRequest ||
                        (this.config.directTranslateLength !== null &&
                            text.length >= this.config.directTranslateLength)) {
                        return [2 /*return*/, this.directTranslate(text, from, to)];
                    }
                    else {
                        return [2 /*return*/, this.makeTask({ text: text, from: from, to: to, context: context, priority: priority })];
                    }
                }
                else {
                    // Split text by words and translate
                    return [2 /*return*/, this.splitAndTranslate(text, from, to, context, priority)];
                }
                return [2 /*return*/];
            });
        });
    };
    Scheduler.prototype.directTranslate = function (text, from, to) {
        return __awaiter(this, void 0, void 0, function () {
            var free;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.semafor.take()];
                    case 1:
                        free = _a.sent();
                        return [2 /*return*/, this.translator.translate(text, from, to).finally(free)];
                }
            });
        });
    };
    Scheduler.prototype.splitAndTranslate = function (text, from, to, context, priority) {
        var e_1, _a;
        var _this = this;
        var splittedText = [];
        var charsetIndexes = [];
        var wordsBuffer = '';
        try {
            for (var _b = __values(text.matchAll(/([^\s]+)(\s*)/g)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var textMatch = _c.value;
                var newPart = textMatch[0];
                var newBuffer = wordsBuffer + newPart;
                // Add word to buffer if can
                if (this.translator.checkLimitExceeding(newBuffer) <= 0) {
                    wordsBuffer = newBuffer;
                    continue;
                }
                // Write and clear buffer if not empthy
                if (wordsBuffer.length > 0) {
                    splittedText.push(wordsBuffer);
                    wordsBuffer = '';
                }
                // Handle new part
                if (this.translator.checkLimitExceeding(newPart) <= 0) {
                    // Add to buffer
                    wordsBuffer += newPart;
                    continue;
                }
                else {
                    // Slice by chars
                    var charsBuffer = newPart;
                    while (charsBuffer.length > 0) {
                        var extraChars = this.translator.checkLimitExceeding(charsBuffer);
                        if (extraChars > 0) {
                            var offset = charsBuffer.length - extraChars;
                            // Write slice and remainder
                            splittedText.push(charsBuffer.slice(0, offset));
                            charsBuffer = charsBuffer.slice(offset);
                            charsetIndexes.push(splittedText.length - 1);
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var ctxPrefix = context.length > 0 ? context + ';' : '';
        return Promise.all(splittedText.map(function (text, index) {
            return charsetIndexes.indexOf(index) !== -1
                ? text
                : _this.makeTask({
                    text: text,
                    from: from,
                    to: to,
                    context: ctxPrefix + "text#".concat(_this.contextCounter++),
                    priority: priority,
                });
        })).then(function (translatedParts) { return translatedParts.join(''); });
    };
    Scheduler.prototype.makeTask = function (_a) {
        var _this = this;
        var text = _a.text, from = _a.from, to = _a.to, priority = _a.priority, _b = _a.context, context = _b === void 0 ? '' : _b;
        return new Promise(function (resolve, reject) {
            _this.addToTaskContainer({
                text: text,
                from: from,
                to: to,
                context: context,
                priority: priority,
                resolve: resolve,
                reject: reject,
            });
        });
    };
    Scheduler.prototype.addToTaskContainer = function (params) {
        var e_2, _a;
        var text = params.text, from = params.from, to = params.to, _b = params.attempt, attempt = _b === void 0 ? 0 : _b, _c = params.context, context = _c === void 0 ? '' : _c, priority = params.priority, resolve = params.resolve, reject = params.reject;
        // create task
        var task = {
            text: text,
            from: from,
            to: to,
            attempt: attempt,
            resolve: resolve,
            reject: reject,
        };
        var container = null;
        var _loop_1 = function (taskContainer) {
            // Skip containers with not equal parameters
            if (['from', 'to', 'context', 'priority'].some(function (key) { return params[key] !== taskContainer[key]; }))
                return "continue";
            // Lightweight check to overflow
            // NOTE: Do strict check here if you need comply a limit contract
            if (this_1.translator.getLengthLimit() >=
                taskContainer.length + task.text.length) {
                taskContainer.tasks.push(task);
                taskContainer.length += task.text.length;
                container = taskContainer;
            }
        };
        var this_1 = this;
        try {
            // try add to exists container
            for (var _d = __values(this.taskContainersStorage), _e = _d.next(); !_e.done; _e = _d.next()) {
                var taskContainer = _e.value;
                _loop_1(taskContainer);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // make container
        if (container === null) {
            var newTaskContainer = {
                context: context,
                priority: priority,
                from: from,
                to: to,
                tasks: [task],
                length: task.text.length,
            };
            this.taskContainersStorage.add(newTaskContainer);
            container = newTaskContainer;
        }
        if (this.config.chunkSizeForInstantTranslate !== null &&
            container.length >= this.config.chunkSizeForInstantTranslate) {
            this.addToTranslateQueue(container);
        }
        else {
            this.updateDelayForAddToTranslateQueue(container);
        }
    };
    Scheduler.prototype.updateDelayForAddToTranslateQueue = function (taskContainer) {
        var _this = this;
        // Flush timer
        if (this.timersMap.has(taskContainer)) {
            // Due to expectation run on one platform, timer objects will same always
            globalThis.clearTimeout(this.timersMap.get(taskContainer));
        }
        this.timersMap.set(taskContainer, globalThis.setTimeout(function () {
            _this.addToTranslateQueue(taskContainer);
        }, this.config.translatePoolDelay));
    };
    Scheduler.prototype.addToTranslateQueue = function (taskContainer) {
        // Flush timer
        if (this.timersMap.has(taskContainer)) {
            // Due to expectation run on one platform, timer objects will same always
            globalThis.clearTimeout(this.timersMap.get(taskContainer));
            this.timersMap.delete(taskContainer);
        }
        this.taskContainersStorage.delete(taskContainer);
        // Resort queue by priority each time to keep consistency
        this.translateQueue = this.translateQueue
            .concat(taskContainer)
            .sort(function (a, b) { return a.priority - b.priority; });
        if (!this.workerState) {
            this.runWorker();
        }
    };
    Scheduler.prototype.runWorker = function () {
        return __awaiter(this, void 0, void 0, function () {
            var firstIteration, _loop_2, this_2, state_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.workerState = true;
                        firstIteration = true;
                        _loop_2 = function () {
                            var workerHandleDelay, iterate, taskContainer, free, textArray;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        workerHandleDelay = this_2.config.taskBatchHandleDelay;
                                        if (!(workerHandleDelay && firstIteration)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, new Promise(function (res) { return setTimeout(res, workerHandleDelay); })];
                                    case 1:
                                        _b.sent();
                                        _b.label = 2;
                                    case 2:
                                        firstIteration = false;
                                        iterate = this_2.getItemFromTranslateQueue();
                                        // Skip when queue empty
                                        if (iterate.done || iterate.value === null)
                                            return [2 /*return*/, "break"];
                                        taskContainer = iterate.value;
                                        return [4 /*yield*/, this_2.semafor.take()];
                                    case 3:
                                        free = _b.sent();
                                        textArray = taskContainer.tasks.map(function (i) { return i.text; });
                                        return [4 /*yield*/, this_2.translator
                                                .translateBatch(textArray, taskContainer.from, taskContainer.to)
                                                .then(function (result) {
                                                for (var index in taskContainer.tasks) {
                                                    var task = taskContainer.tasks[index];
                                                    var translatedText = result[index];
                                                    if (translatedText !== null) {
                                                        task.resolve(translatedText);
                                                    }
                                                    else {
                                                        _this.taskErrorHandler(task, new Error("Translator module can't translate this"), taskContainer.context, taskContainer.priority);
                                                    }
                                                }
                                            })
                                                .catch(function (reason) {
                                                var e_3, _a;
                                                console.error(reason);
                                                try {
                                                    for (var _b = (e_3 = void 0, __values(taskContainer.tasks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                                        var task = _c.value;
                                                        _this.taskErrorHandler(task, reason, taskContainer.context, taskContainer.priority);
                                                    }
                                                }
                                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                                finally {
                                                    try {
                                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                                    }
                                                    finally { if (e_3) throw e_3.error; }
                                                }
                                            })
                                                .finally(free)];
                                    case 4:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_2 = this;
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_2()];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3:
                        this.workerState = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    Scheduler.prototype.taskErrorHandler = function (task, error, context, priority) {
        if (task.attempt >= this.config.translateRetryAttemptLimit) {
            if (this.config.isAllowDirectTranslateBadChunks) {
                var text = task.text, from = task.from, to = task.to, resolve = task.resolve, reject = task.reject;
                this.directTranslate(text, from, to).then(resolve, reject);
            }
            else {
                task.reject(error);
            }
        }
        else {
            this.addToTaskContainer(__assign(__assign({}, task), { attempt: task.attempt + 1, context: context, priority: priority }));
        }
    };
    return Scheduler;
}());
export { Scheduler };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvU2NoZWR1bGVyL1NjaGVkdWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBMkd0RDs7Ozs7O0dBTUc7QUFDSDtJQVlDLG1CQUFZLFVBQXFDLEVBQUUsTUFBZTtRQUFsRSxpQkFVQztRQW5CZ0IsV0FBTSxHQUFxQjtZQUMzQywwQkFBMEIsRUFBRSxDQUFDO1lBQzdCLCtCQUErQixFQUFFLElBQUk7WUFDckMscUJBQXFCLEVBQUUsSUFBSTtZQUMzQixrQkFBa0IsRUFBRSxHQUFHO1lBQ3ZCLDRCQUE0QixFQUFFLElBQUk7WUFDbEMsb0JBQW9CLEVBQUUsSUFBSTtTQUMxQixDQUFDO1FBY00sbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFtSFYsMEJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQWlCLENBQUM7UUF1RWpELGNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBMEMsQ0FBQztRQWdCL0U7OztXQUdHO1FBQ0ssbUJBQWMsR0FBb0IsRUFBRSxDQUFDO1FBcUI3Qzs7O1dBR0c7UUFDSyw4QkFBeUIsR0FBRzs7WUFDbkMsT0FBTztnQkFDTixJQUFJLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQztnQkFDdEMsS0FBSyxFQUFFLE1BQUEsS0FBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsbUNBQUksSUFBSTthQUN4QyxDQUFDO1FBQ0gsQ0FBQyxDQUFDO1FBRU0sZ0JBQVcsR0FBRyxLQUFLLENBQUM7UUF6UDNCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBRTdCLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUN6QixLQUFLLElBQU0sR0FBRyxJQUFJLE1BQU0sRUFBRTtnQkFDeEIsSUFBSSxDQUFDLE1BQWMsQ0FBQyxHQUFHLENBQUMs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QixhQUFhLENBQUMsUUFBUSxDQUN0QixDQUFDO3FEQUNGOzs7Ozs7Ozs7NENBQ0YsQ0FBQyxDQUFDO2lEQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQTs7d0NBL0JmLFNBK0JlLENBQUM7Ozs7Ozs7OzZCQWxEVixJQUFJOzs7Ozs7Ozt3QkFxRFgsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7Ozs7O0tBQ3pCO0lBRU8sb0NBQWdCLEdBQXhCLFVBQXlCLElBQVUsRUFBRSxLQUFVLEVBQUUsT0FBZSxFQUFFLFFBQWdCO1FBQ2pGLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLDBCQUEwQixFQUFFO1lBQzNELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQywrQkFBK0IsRUFBRTtnQkFDeEMsSUFBQSxJQUFJLEdBQWdDLElBQUksS0FBcEMsRUFBRSxJQUFJLEdBQTBCLElBQUksS0FBOUIsRUFBRSxFQUFFLEdBQXNCLElBQUksR0FBMUIsRUFBRSxPQUFPLEdBQWEsSUFBSSxRQUFqQixFQUFFLE1BQU0sR0FBSyxJQUFJLE9BQVQsQ0FBVTtnQkFDakQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDM0Q7aUJBQU07Z0JBQ04sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNuQjtTQUNEO2FBQU07WUFDTixJQUFJLENBQUMsa0JBQWtCLHVCQUNuQixJQUFJLEtBQ1AsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUN6QixPQUFPLFNBQUEsRUFDUCxRQUFRLFVBQUEsSUFDUCxDQUFDO1NBQ0g7SUFDRixDQUFDO0lBQ0YsZ0JBQUM7QUFBRCxDQXBWQSxBQW9WQyxJQUFBIiwiZmlsZSI6InV0aWwvU2NoZWR1bGVyL1NjaGVkdWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElUcmFuc2xhdGVPcHRpb25zLCBJU2NoZWR1bGVyIH0gZnJvbSAnLi9JU2NoZWR1bGVyJztcbmltcG9ydCB7XG5cdGxhbmdDb2RlLFxuXHRsYW5nQ29kZVdpdGhBdXRvLFxuXHRUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLFxufSBmcm9tICcuLi8uLi90eXBlcy9UcmFuc2xhdG9yJztcbmltcG9ydCB7IFF1ZXVlU2VtYWZvciB9IGZyb20gJy4uLy4uL2xpYi9RdWV1ZVNlbWFmb3InO1xuXG5pbnRlcmZhY2UgQ29uZmlnIHtcblx0LyoqXG5cdCAqIE51bWJlciBvZiBhdHRlbXB0cyBmb3IgcmV0cnkgcmVxdWVzdFxuXHQgKi9cblx0dHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQ/OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIElmIHRydWUgLSByZWplY3RlZCByZXF1ZXN0cyB3aWxsIHVzZSBkaXJlY3QgdHJhbnNsYXRlXG5cdCAqL1xuXHRpc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzPzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogTGVuZ3RoIG9mIHN0cmluZyBmb3IgZGlyZWN0IHRyYW5zbGF0ZS5cblx0ICpcblx0ICogbnVsbCBmb3IgZGlzYWJsZSB0aGUgY29uZGl0aW9uXG5cdCAqL1xuXHRkaXJlY3RUcmFuc2xhdGVMZW5ndGg/OiBudW1iZXIgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBEZWxheSBmb3IgdHJhbnNsYXRlIGEgY2h1bmsuIFRoZSBiaWdnZXIgdGhlIG1vcmUgcmVxdWVzdHMgd2lsbCBjb2xsZWN0XG5cdCAqL1xuXHR0cmFuc2xhdGVQb29sRGVsYXk/OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFdoZW4gY2h1bmsgY29sbGVjdCB0aGlzIHNpemUsIGl0J3Mgd2lsbCBiZSBpbnN0YW50IGFkZCB0byBhIHRyYW5zbGF0ZSBxdWV1ZVxuXHQgKlxuXHQgKiBudWxsIGZvciBkaXNhYmxlIHRoZSBjb25kaXRpb25cblx0ICovXG5cdGNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGU/OiBudW1iZXIgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBQYXVzZSBiZXR3ZWVuIGhhbmRsZSB0YXNrIGJhdGNoZXNcblx0ICpcblx0ICogSXQgbWF5IGJlIHVzZWZ1bCB0byBhd2FpdCBhY2N1bXVsYXRpbmcgYSB0YXNrIGJhdGNoZXMgaW4gcXVldWUgdG8gY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyIGFuZCBkb24ndCB0cmFuc2xhdGUgZmlyc3QgdGFzayBiYXRjaCBpbW1lZGlhdGVseVxuXHQgKlxuXHQgKiBXQVJOSU5HOiB0aGlzIG9wdGlvbiBtdXN0IGJlIHVzZWQgb25seSBmb3IgY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyISBTZXQgc21hbGwgdmFsdWUgYWx3YXlzICgxMC01MG1zKVxuXHQgKlxuXHQgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIGRpc2FibGVkIChieSBkZWZhdWx0KSBhbmQgeW91IGNhbGwgdHJhbnNsYXRlIG1ldGhvZCBmb3IgdGV4dHMgd2l0aCBwcmlvcml0eSAxIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGZvciB0ZXh0IHdpdGggcHJpb3JpdHkgMiwgZmlyc3QgcmVxdWVzdCB3aWxsIGhhdmUgbGVzcyBkZWxheSBmb3IgdHJhbnNsYXRlIGFuZCB3aWxsIHRyYW5zbGF0ZSBmaXJzdCwgZXZlbiB3aXRoIGxvd2VyIHByaW9yaXR5LCBiZWNhdXNlIHdvcmtlciB3aWxsIHRyYW5zbGF0ZSBmaXJzdCB0YXNrIGltbWVkaWF0ZWx5IGFmdGVyIGRlbGF5IGRlZmluZWQgYnkgb3B0aW9uIGB0cmFuc2xhdGVQb29sRGVsYXlgXG5cdCAqL1xuXHR0YXNrQmF0Y2hIYW5kbGVEZWxheT86IG51bGwgfCBudW1iZXI7XG59XG5cbmludGVyZmFjZSBUYXNrQ29uc3RydWN0b3Ige1xuXHR0ZXh0OiBzdHJpbmc7XG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblxuXHQvKipcblx0ICogVG8gY29tYmluZSB0YXNrcyBieSB1bmlxdWUga2V5XG5cdCAqL1xuXHRjb250ZXh0Pzogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUbyBjb21iaW5lIGFuZCBzb3J0IHRhc2tzIGJ5IHByaW9yaXR5XG5cdCAqL1xuXHRwcmlvcml0eTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVGFza0NvbnN0cnVjdG9ySW50ZXJuYWwgZXh0ZW5kcyBUYXNrQ29uc3RydWN0b3Ige1xuXHQvKipcblx0ICogQ3VycmVudCByZXRyeSBhdHRlbXB0XG5cdCAqL1xuXHRhdHRlbXB0PzogbnVtYmVyO1xuXG5cdHJlc29sdmU6ICh2YWx1ZTogc3RyaW5nIHwgUHJvbWlzZUxpa2U8c3RyaW5nPikgPT4gdm9pZDtcblx0cmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVGFzayB7XG5cdHRleHQ6IHN0cmluZztcblx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0bztcblx0dG86IGxhbmdDb2RlO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IHJldHJ5IGF0dGVtcHRcblx0ICovXG5cdGF0dGVtcHQ6IG51bWJlcjtcblxuXHRyZXNvbHZlOiAodmFsdWU6IHN0cmluZyB8IFByb21pc2VMaWtlPHN0cmluZz4pID0+IHZvaWQ7XG5cdHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFRhc2tDb250YWluZXIge1xuXHQvKipcblx0ICogRm9yIGNvbWJpbmUgdGFza3MgYnkgdW5pcXVlIGtleVxuXHQgKi9cblx0Y29udGV4dDogc3RyaW5nO1xuXG5cdHByaW9yaXR5OiBudW1iZXI7XG5cblx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0bztcblx0dG86IGxhbmdDb2RlO1xuXHR0YXNrczogVGFza1tdO1xuXG5cdC8qKlxuXHQgKiBUb3RhbCBsZW5ndGggb2YgdGV4dCBmcm9tIGFsbCB0YXNrc1xuXHQgKi9cblx0bGVuZ3RoOiBudW1iZXI7XG59XG5cbnR5cGUgSXRlcmF0b3JTdGVwPFQ+ID0ge1xuXHRkb25lOiBib29sZWFuO1xuXHR2YWx1ZTogVCB8IG51bGw7XG59O1xuXG4vKipcbiAqIE1vZHVsZSBmb3Igc2NoZWR1bGluZyBhbmQgb3B0aW1pemF0aW9uIG9mIHRyYW5zbGF0ZSBhIHRleHQgc3RyZWFtc1xuICpcbiAqIC0gSXQgY2FuIHVuaW9uIG1hbnkgdHJhbnNsYXRlIHJlcXVlc3RzIHRvIG9uZVxuICogLSBZb3UgY2FuIGdyb3VwIGFueSByZXF1ZXN0cyBieSBjb250ZXh0XG4gKiAtIEl0J3MgY29uZmlndXJhYmxlLiBZb3UgY2FuIHNldCByZXRyeSBsaW1pdCBhbmQgZWRnZSBmb3IgZGlyZWN0IHRyYW5zbGF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2NoZWR1bGVyIGltcGxlbWVudHMgSVNjaGVkdWxlciB7XG5cdHByaXZhdGUgcmVhZG9ubHkgc2VtYWZvcjtcblx0cHJpdmF0ZSByZWFkb25seSB0cmFuc2xhdG9yO1xuXHRwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogUmVxdWlyZWQ8Q29uZmlnPiA9IHtcblx0XHR0cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdDogMixcblx0XHRpc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzOiB0cnVlLFxuXHRcdGRpcmVjdFRyYW5zbGF0ZUxlbmd0aDogbnVsbCxcblx0XHR0cmFuc2xhdGVQb29sRGVsYXk6IDMwMCxcblx0XHRjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlOiBudWxsLFxuXHRcdHRhc2tCYXRjaEhhbmRsZURlbGF5OiBudWxsLFxuXHR9O1xuXG5cdGNvbnN0cnVjdG9yKHRyYW5zbGF0b3I6IFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnMsIGNvbmZpZz86IENvbmZpZykge1xuXHRcdHRoaXMudHJhbnNsYXRvciA9IHRyYW5zbGF0b3I7XG5cblx0XHRpZiAoY29uZmlnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuXHRcdFx0XHQodGhpcy5jb25maWcgYXMgYW55KVtrZXldID0gKGNvbmZpZyBhcyBhbnkpW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZW1hZm9yID0gbmV3IFF1ZXVlU2VtYWZvcih7IHRpbWVvdXQ6IHRyYW5zbGF0b3IuZ2V0UmVxdWVzdHNUaW1lb3V0KCkgfSk7XG5cdH1cblxuXHRwcml2YXRlIGNvbnRleHRDb3VudGVyID0gMDtcblx0cHVibGljIGFzeW5jIHRyYW5zbGF0ZShcblx0XHR0ZXh0OiBzdHJpbmcsXG5cdFx0ZnJvbTogbGFuZ0NvZGVXaXRoQXV0byxcblx0XHR0bzogbGFuZ0NvZGUsXG5cdFx0b3B0aW9ucz86IElUcmFuc2xhdGVPcHRpb25zLFxuXHQpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRjb250ZXh0ID0gJycsXG5cdFx0XHRwcmlvcml0eSA9IDAsXG5cdFx0XHRkaXJlY3RUcmFuc2xhdGU6IGRpcmVjdFRyYW5zbGF0ZUZvclRoaXNSZXF1ZXN0ID0gZmFsc2UsXG5cdFx0fSA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcblxuXHRcdGlmICh0aGlzLnRyYW5zbGF0b3IuY2hlY2tMaW1pdEV4Y2VlZGluZyh0ZXh0KSA8PSAwKSB7XG5cdFx0XHQvLyBEaXJlY3QgdHJhbnNsYXRlXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGRpcmVjdFRyYW5zbGF0ZUZvclRoaXNSZXF1ZXN0IHx8XG5cdFx0XHRcdCh0aGlzLmNvbmZpZy5kaXJlY3RUcmFuc2xhdGVMZW5ndGggIT09IG51bGwgJiZcblx0XHRcdFx0XHR0ZXh0Lmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5kaXJlY3RUcmFuc2xhdGVMZW5ndGgpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGlyZWN0VHJhbnNsYXRlKHRleHQsIGZyb20sIHRvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1ha2VUYXNrKHsgdGV4dDogdGV4dCwgZnJvbSwgdG8sIGNvbnRleHQsIHByaW9yaXR5IH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTcGxpdCB0ZXh0IGJ5IHdvcmRzIGFuZCB0cmFuc2xhdGVcblx0XHRcdHJldHVybiB0aGlzLnNwbGl0QW5kVHJhbnNsYXRlKHRleHQsIGZyb20sIHRvLCBjb250ZXh0LCBwcmlvcml0eSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBkaXJlY3RUcmFuc2xhdGUodGV4dDogc3RyaW5nLCBmcm9tOiBsYW5nQ29kZVdpdGhBdXRvLCB0bzogbGFuZ0NvZGUpIHtcblx0XHRjb25zdCBmcmVlID0gYXdhaXQgdGhpcy5zZW1hZm9yLnRha2UoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bykuZmluYWxseShmcmVlKTtcblx0fVxuXG5cdHByaXZhdGUgc3BsaXRBbmRUcmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGZyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0dG86IGxhbmdDb2RlLFxuXHRcdGNvbnRleHQ6IHN0cmluZyxcblx0XHRwcmlvcml0eTogbnVtYmVyLFxuXHQpIHtcblx0XHRjb25zdCBzcGxpdHRlZFRleHQ6IHN0cmluZ1tdID0gW107XG5cdFx0Y29uc3QgY2hhcnNldEluZGV4ZXM6IG51bWJlcltdID0gW107XG5cblx0XHRsZXQgd29yZHNCdWZmZXIgPSAnJztcblx0XHRmb3IgKGNvbnN0IHRleHRNYXRjaCBvZiB0ZXh0Lm1hdGNoQWxsKC8oW15cXHNdKykoXFxzKikvZykpIHtcblx0XHRcdGNvbnN0IG5ld1BhcnQgPSB0ZXh0TWF0Y2hbMF07XG5cdFx0XHRjb25zdCBuZXdCdWZmZXIgPSB3b3Jkc0J1ZmZlciArIG5ld1BhcnQ7XG5cblx0XHRcdC8vIEFkZCB3b3JkIHRvIGJ1ZmZlciBpZiBjYW5cblx0XHRcdGlmICh0aGlzLnRyYW5zbGF0b3IuY2hlY2tMaW1pdEV4Y2VlZGluZyhuZXdCdWZmZXIpIDw9IDApIHtcblx0XHRcdFx0d29yZHNCdWZmZXIgPSBuZXdCdWZmZXI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcml0ZSBhbmQgY2xlYXIgYnVmZmVyIGlmIG5vdCBlbXB0aHlcblx0XHRcdGlmICh3b3Jkc0J1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNwbGl0dGVkVGV4dC5wdXNoKHdvcmRzQnVmZmVyKTtcblx0XHRcdFx0d29yZHNCdWZmZXIgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIG5ldyBwYXJ0XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcobmV3UGFydCkgPD0gMCkge1xuXHRcdFx0XHQvLyBBZGQgdG8gYnVmZmVyXG5cdFx0XHRcdHdvcmRzQnVmZmVyICs9IG5ld1BhcnQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU2xpY2UgYnkgY2hhcnNcblx0XHRcdFx0bGV0IGNoYXJzQnVmZmVyID0gbmV3UGFydDtcblx0XHRcdFx0d2hpbGUgKGNoYXJzQnVmZmVyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zdCBleHRyYUNoYXJzID0gdGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcoY2hhcnNCdWZmZXIpO1xuXHRcdFx0XHRcdGlmIChleHRyYUNoYXJzID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gY2hhcnNCdWZmZXIubGVuZ3RoIC0gZXh0cmFDaGFycztcblxuXHRcdFx0XHRcdFx0Ly8gV3JpdGUgc2xpY2UgYW5kIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0c3BsaXR0ZWRUZXh0LnB1c2goY2hhcnNCdWZmZXIuc2xpY2UoMCwgb2Zmc2V0KSk7XG5cdFx0XHRcdFx0XHRjaGFyc0J1ZmZlciA9IGNoYXJzQnVmZmVyLnNsaWNlKG9mZnNldCk7XG5cblx0XHRcdFx0XHRcdGNoYXJzZXRJbmRleGVzLnB1c2goc3BsaXR0ZWRUZXh0Lmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGN0eFByZWZpeCA9IGNvbnRleHQubGVuZ3RoID4gMCA/IGNvbnRleHQgKyAnOycgOiAnJztcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXG5cdFx0XHRzcGxpdHRlZFRleHQubWFwKCh0ZXh0LCBpbmRleCkgPT5cblx0XHRcdFx0Y2hhcnNldEluZGV4ZXMuaW5kZXhPZihpbmRleCkgIT09IC0xXG5cdFx0XHRcdFx0PyB0ZXh0XG5cdFx0XHRcdFx0OiB0aGlzLm1ha2VUYXNrKHtcblx0XHRcdFx0XHRcdHRleHQsXG5cdFx0XHRcdFx0XHRmcm9tLFxuXHRcdFx0XHRcdFx0dG8sXG5cdFx0XHRcdFx0XHRjb250ZXh0OiBjdHhQcmVmaXggKyBgdGV4dCMke3RoaXMuY29udGV4dENvdW50ZXIrK31gLFxuXHRcdFx0XHRcdFx0cHJpb3JpdHksXG5cdFx0XHRcdFx0ICB9KSxcblx0XHRcdCksXG5cdFx0KS50aGVuKCh0cmFuc2xhdGVkUGFydHMpID0+IHRyYW5zbGF0ZWRQYXJ0cy5qb2luKCcnKSk7XG5cdH1cblxuXHRwcml2YXRlIG1ha2VUYXNrKHsgdGV4dCwgZnJvbSwgdG8sIHByaW9yaXR5LCBjb250ZXh0ID0gJycgfTogVGFza0NvbnN0cnVjdG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0dGhpcy5hZGRUb1Rhc2tDb250YWluZXIoe1xuXHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRmcm9tLFxuXHRcdFx0XHR0byxcblx0XHRcdFx0Y29udGV4dCxcblx0XHRcdFx0cHJpb3JpdHksXG5cdFx0XHRcdHJlc29sdmUsXG5cdFx0XHRcdHJlamVjdCxcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSB0YXNrQ29udGFpbmVyc1N0b3JhZ2UgPSBuZXcgU2V0PFRhc2tDb250YWluZXI+KCk7XG5cdHByaXZhdGUgYWRkVG9UYXNrQ29udGFpbmVyKHBhcmFtczogVGFza0NvbnN0cnVjdG9ySW50ZXJuYWwpIHtcblx0XHRjb25zdCB7XG5cdFx0XHR0ZXh0LFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvLFxuXHRcdFx0YXR0ZW1wdCA9IDAsXG5cdFx0XHRjb250ZXh0ID0gJycsXG5cdFx0XHRwcmlvcml0eSxcblx0XHRcdHJlc29sdmUsXG5cdFx0XHRyZWplY3QsXG5cdFx0fSA9IHBhcmFtcztcblxuXHRcdC8vIGNyZWF0ZSB0YXNrXG5cdFx0Y29uc3QgdGFzazogVGFzayA9IHtcblx0XHRcdHRleHQsXG5cdFx0XHRmcm9tLFxuXHRcdFx0dG8sXG5cdFx0XHRhdHRlbXB0LFxuXHRcdFx0cmVzb2x2ZSxcblx0XHRcdHJlamVjdCxcblx0XHR9O1xuXG5cdFx0bGV0IGNvbnRhaW5lcjogVGFza0NvbnRhaW5lciB8IG51bGwgPSBudWxsO1xuXG5cdFx0Ly8gdHJ5IGFkZCB0byBleGlzdHMgY29udGFpbmVyXG5cdFx0Zm9yIChjb25zdCB0YXNrQ29udGFpbmVyIG9mIHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlKSB7XG5cdFx0XHQvLyBTa2lwIGNvbnRhaW5lcnMgd2l0aCBub3QgZXF1YWwgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRbJ2Zyb20nLCAndG8nLCAnY29udGV4dCcsICdwcmlvcml0eSddLnNvbWUoXG5cdFx0XHRcdFx0KGtleSkgPT4gKHBhcmFtcyBhcyBhbnkpW2tleV0gIT09ICh0YXNrQ29udGFpbmVyIGFzIGFueSlba2V5XSxcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly8gTGlnaHR3ZWlnaHQgY2hlY2sgdG8gb3ZlcmZsb3dcblx0XHRcdC8vIE5PVEU6IERvIHN0cmljdCBjaGVjayBoZXJlIGlmIHlvdSBuZWVkIGNvbXBseSBhIGxpbWl0IGNvbnRyYWN0XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMudHJhbnNsYXRvci5nZXRMZW5ndGhMaW1pdCgpID49XG5cdFx0XHRcdHRhc2tDb250YWluZXIubGVuZ3RoICsgdGFzay50ZXh0Lmxlbmd0aFxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhc2tDb250YWluZXIudGFza3MucHVzaCh0YXNrKTtcblx0XHRcdFx0dGFza0NvbnRhaW5lci5sZW5ndGggKz0gdGFzay50ZXh0Lmxlbmd0aDtcblx0XHRcdFx0Y29udGFpbmVyID0gdGFza0NvbnRhaW5lcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBtYWtlIGNvbnRhaW5lclxuXHRcdGlmIChjb250YWluZXIgPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IG5ld1Rhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIgPSB7XG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRmcm9tLFxuXHRcdFx0XHR0byxcblx0XHRcdFx0dGFza3M6IFt0YXNrXSxcblx0XHRcdFx0bGVuZ3RoOiB0YXNrLnRleHQubGVuZ3RoLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlLmFkZChuZXdUYXNrQ29udGFpbmVyKTtcblx0XHRcdGNvbnRhaW5lciA9IG5ld1Rhc2tDb250YWluZXI7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5jb25maWcuY2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZSAhPT0gbnVsbCAmJlxuXHRcdFx0Y29udGFpbmVyLmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5jaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLmFkZFRvVHJhbnNsYXRlUXVldWUoY29udGFpbmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGVEZWxheUZvckFkZFRvVHJhbnNsYXRlUXVldWUoY29udGFpbmVyKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlYWRvbmx5IHRpbWVyc01hcCA9IG5ldyBNYXA8VGFza0NvbnRhaW5lciwgbnVtYmVyIHwgTm9kZUpTLlRpbWVvdXQ+KCk7XG5cdHByaXZhdGUgdXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIpIHtcblx0XHQvLyBGbHVzaCB0aW1lclxuXHRcdGlmICh0aGlzLnRpbWVyc01hcC5oYXModGFza0NvbnRhaW5lcikpIHtcblx0XHRcdC8vIER1ZSB0byBleHBlY3RhdGlvbiBydW4gb24gb25lIHBsYXRmb3JtLCB0aW1lciBvYmplY3RzIHdpbGwgc2FtZSBhbHdheXNcblx0XHRcdGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzTWFwLmdldCh0YXNrQ29udGFpbmVyKSBhcyBhbnkpO1xuXHRcdH1cblxuXHRcdHRoaXMudGltZXJzTWFwLnNldChcblx0XHRcdHRhc2tDb250YWluZXIsXG5cdFx0XHRnbG9iYWxUaGlzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmFkZFRvVHJhbnNsYXRlUXVldWUodGFza0NvbnRhaW5lcik7XG5cdFx0XHR9LCB0aGlzLmNvbmZpZy50cmFuc2xhdGVQb29sRGVsYXkpLFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVGFza3MgcXVldWUgd2l0aCBpdGVtcyBzb3J0ZWQgYnkgcHJpb3JpdHlcblx0ICogSXQgbXVzdCBiZSBoYW5kbGVkIGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqL1xuXHRwcml2YXRlIHRyYW5zbGF0ZVF1ZXVlOiBUYXNrQ29udGFpbmVyW10gPSBbXTtcblx0cHJpdmF0ZSBhZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXI6IFRhc2tDb250YWluZXIpIHtcblx0XHQvLyBGbHVzaCB0aW1lclxuXHRcdGlmICh0aGlzLnRpbWVyc01hcC5oYXModGFza0NvbnRhaW5lcikpIHtcblx0XHRcdC8vIER1ZSB0byBleHBlY3RhdGlvbiBydW4gb24gb25lIHBsYXRmb3JtLCB0aW1lciBvYmplY3RzIHdpbGwgc2FtZSBhbHdheXNcblx0XHRcdGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzTWFwLmdldCh0YXNrQ29udGFpbmVyKSBhcyBhbnkpO1xuXHRcdFx0dGhpcy50aW1lcnNNYXAuZGVsZXRlKHRhc2tDb250YWluZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMudGFza0NvbnRhaW5lcnNTdG9yYWdlLmRlbGV0ZSh0YXNrQ29udGFpbmVyKTtcblxuXHRcdC8vIFJlc29ydCBxdWV1ZSBieSBwcmlvcml0eSBlYWNoIHRpbWUgdG8ga2VlcCBjb25zaXN0ZW5jeVxuXHRcdHRoaXMudHJhbnNsYXRlUXVldWUgPSB0aGlzLnRyYW5zbGF0ZVF1ZXVlXG5cdFx0XHQuY29uY2F0KHRhc2tDb250YWluZXIpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG5cdFx0aWYgKCF0aGlzLndvcmtlclN0YXRlKSB7XG5cdFx0XHR0aGlzLnJ1bldvcmtlcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZmlyc3QgaXRlbSBmcm9tIHF1ZXVlIGFuZCBkZWxldGUgaXQgZnJvbSBxdWV1ZVxuXHQgKiBJdGVtcyBpcyBzb3J0ZWQgYnkgcHJpb3JpdHlcblx0ICovXG5cdHByaXZhdGUgZ2V0SXRlbUZyb21UcmFuc2xhdGVRdWV1ZSA9ICgpOiBJdGVyYXRvclN0ZXA8VGFza0NvbnRhaW5lcj4gPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkb25lOiB0aGlzLnRyYW5zbGF0ZVF1ZXVlLmxlbmd0aCA9PT0gMCxcblx0XHRcdHZhbHVlOiB0aGlzLnRyYW5zbGF0ZVF1ZXVlLnBvcCgpID8/IG51bGwsXG5cdFx0fTtcblx0fTtcblxuXHRwcml2YXRlIHdvcmtlclN0YXRlID0gZmFsc2U7XG5cdHByaXZhdGUgYXN5bmMgcnVuV29ya2VyKCkge1xuXHRcdHRoaXMud29ya2VyU3RhdGUgPSB0cnVlO1xuXG5cdFx0bGV0IGZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Ly8gRGVsYXkgZmlyc3QgaXRlcmF0aW9uIHRvIGF3YWl0IGZpbGwgdGhlIHF1ZXVlLCB0byBjb25zaWRlciBwcmlvcml0eSBiZXR0ZXJcblx0XHRcdGNvbnN0IHdvcmtlckhhbmRsZURlbGF5ID0gdGhpcy5jb25maWcudGFza0JhdGNoSGFuZGxlRGVsYXk7XG5cdFx0XHRpZiAod29ya2VySGFuZGxlRGVsYXkgJiYgZmlyc3RJdGVyYXRpb24pIHtcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIHdvcmtlckhhbmRsZURlbGF5KSk7XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0SXRlcmF0aW9uID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGl0ZXJhdGUgPSB0aGlzLmdldEl0ZW1Gcm9tVHJhbnNsYXRlUXVldWUoKTtcblxuXHRcdFx0Ly8gU2tpcCB3aGVuIHF1ZXVlIGVtcHR5XG5cdFx0XHRpZiAoaXRlcmF0ZS5kb25lIHx8IGl0ZXJhdGUudmFsdWUgPT09IG51bGwpIGJyZWFrO1xuXG5cdFx0XHRjb25zdCB0YXNrQ29udGFpbmVyID0gaXRlcmF0ZS52YWx1ZTtcblxuXHRcdFx0Y29uc3QgZnJlZSA9IGF3YWl0IHRoaXMuc2VtYWZvci50YWtlKCk7XG5cblx0XHRcdGNvbnN0IHRleHRBcnJheSA9IHRhc2tDb250YWluZXIudGFza3MubWFwKChpKSA9PiBpLnRleHQpO1xuXHRcdFx0YXdhaXQgdGhpcy50cmFuc2xhdG9yXG5cdFx0XHRcdC50cmFuc2xhdGVCYXRjaCh0ZXh0QXJyYXksIHRhc2tDb250YWluZXIuZnJvbSwgdGFza0NvbnRhaW5lci50bylcblx0XHRcdFx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgaW5kZXggaW4gdGFza0NvbnRhaW5lci50YXNrcykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGFzayA9IHRhc2tDb250YWluZXIudGFza3NbaW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmFuc2xhdGVkVGV4dCA9IHJlc3VsdFtpbmRleF07XG5cdFx0XHRcdFx0XHRpZiAodHJhbnNsYXRlZFRleHQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dGFzay5yZXNvbHZlKHRyYW5zbGF0ZWRUZXh0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudGFza0Vycm9ySGFuZGxlcihcblx0XHRcdFx0XHRcdFx0XHR0YXNrLFxuXHRcdFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIlRyYW5zbGF0b3IgbW9kdWxlIGNhbid0IHRyYW5zbGF0ZSB0aGlzXCIpLFxuXHRcdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIuY29udGV4dCxcblx0XHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLnByaW9yaXR5LFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKChyZWFzb24pID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKHJlYXNvbik7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHRhc2sgb2YgdGFza0NvbnRhaW5lci50YXNrcykge1xuXHRcdFx0XHRcdFx0dGhpcy50YXNrRXJyb3JIYW5kbGVyKFxuXHRcdFx0XHRcdFx0XHR0YXNrLFxuXHRcdFx0XHRcdFx0XHRyZWFzb24sXG5cdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIuY29udGV4dCxcblx0XHRcdFx0XHRcdFx0dGFza0NvbnRhaW5lci5wcmlvcml0eSxcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmluYWxseShmcmVlKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlclN0YXRlID0gZmFsc2U7XG5cdH1cblxuXHRwcml2YXRlIHRhc2tFcnJvckhhbmRsZXIodGFzazogVGFzaywgZXJyb3I6IGFueSwgY29udGV4dDogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyKSB7XG5cdFx0aWYgKHRhc2suYXR0ZW1wdCA+PSB0aGlzLmNvbmZpZy50cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdCkge1xuXHRcdFx0aWYgKHRoaXMuY29uZmlnLmlzQWxsb3dEaXJlY3RUcmFuc2xhdGVCYWRDaHVua3MpIHtcblx0XHRcdFx0Y29uc3QgeyB0ZXh0LCBmcm9tLCB0bywgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0YXNrO1xuXHRcdFx0XHR0aGlzLmRpcmVjdFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFzay5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFkZFRvVGFza0NvbnRhaW5lcih7XG5cdFx0XHRcdC4uLnRhc2ssXG5cdFx0XHRcdGF0dGVtcHQ6IHRhc2suYXR0ZW1wdCArIDEsXG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG4iXX0=
